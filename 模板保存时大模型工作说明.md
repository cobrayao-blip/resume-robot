# 模板保存时大模型工作说明

本文档详细说明在模板保存时，大模型（LLM）对模板做了哪些分析和处理工作。

## 一、工作流程概述

当用户保存模板时，系统会调用大模型对模板结构进行智能分析，生成字段映射规则。这个过程的目的是：

1. **预分析模板结构**：在模板保存时就分析好字段映射关系
2. **优化填充性能**：后续填充模板时可以直接使用映射规则，减少AI调用
3. **提高填充准确性**：通过预分析，确保字段映射的准确性

## 二、调用时机

**触发位置**：`backend/app/api/v1/endpoints/templates.py` - `create_template` 函数

**调用流程**：
```
用户保存模板
  ↓
POST /templates/
  ↓
create_template() 函数
  ↓
llm_service.analyze_template_structure()  ← 大模型分析
  ↓
生成 field_mapping 并存储到 template_schema
  ↓
保存模板到数据库
```

## 三、大模型的具体工作

### 1. 分析模板结构

**输入数据**：
- 模板的所有组件（components）
- 每个组件的字段列表（fields）
- 字段的元数据（id、label、description、dataSource、synonyms等）

**处理过程**：
```python
# 提取模板结构信息（精简版，只发送必要信息）
components_info = []
for comp in template_structure.get("components", []):
    comp_type = comp.get("type", "")  # basic_info, work_experience等
    comp_title = comp.get("title", "")
    fields = comp.get("fields", [])
    
    # 为每个字段提取元数据
    for field in fields:
        field_id = field.get("id", "")
        field_label = field.get("label", "")
        field_data_source = field.get("dataSource", "")
        field_synonyms = field.get("synonyms", [])
        # ... 其他元数据
```

### 2. 生成字段映射规则

**核心任务**：
1. **理解组件类型**：识别 basic_info、work_experience、education、skills、projects 等组件
2. **分析字段含义**：理解每个字段的语义和用途
3. **生成数据源路径**：为每个字段生成从 `parsed_data` 中提取数据的路径
4. **识别映射类型**：判断是直接映射、回退映射还是组合映射

**映射类型**：

#### a) 直接映射（direct）
```json
{
  "name": {
    "data_source": "parsed_data.basic_info.name",
    "type": "direct",
    "transform": null
  }
}
```
- 字段直接对应解析数据中的某个字段
- 无需转换，直接使用

#### b) 回退映射（fallback）
```json
{
  "current_location": {
    "data_source": "parsed_data.basic_info.location || parsed_data.basic_info.work_location",
    "type": "fallback",
    "transform": null
  }
}
```
- 优先使用第一个数据源，如果不存在则使用第二个
- 适用于字段可能有多个来源的情况

#### c) 组合映射（combine）
```json
{
  "period": {
    "data_source": "parsed_data.work_experiences[]",
    "type": "combine",
    "transform": "combine(start_date, end_date, format='YYYY-MM - YYYY-MM')"
  }
}
```
- 需要组合多个字段生成一个字段
- 例如：将 start_date 和 end_date 组合成 period

### 3. 识别复杂字段

**复杂字段特征**：
- 没有明确的数据源（`dataSource` 为空）
- 字段类型为复杂类型（textarea、richtext、markdown）
- 需要从文本中提取或转换的字段

**处理方式**：
```python
needs_ai = False
# 如果没有明确的数据源，认为需要AI处理
if not field_data_source:
    needs_ai = True
# 复杂类型（textarea、richtext等）默认需要AI辅助
if field_type in ["textarea", "richtext", "markdown"] and not field_data_source:
    needs_ai = True
```

**复杂字段标记**：
```json
{
  "complex_fields": [
    {
      "component_type": "work_experience",
      "field_id": "responsibilities",
      "needs_ai_extraction": true,
      "reason": "需要从工作描述中提取"
    }
  ]
}
```

### 4. 生成完整的映射规则

**输出格式**：
```json
{
  "field_mapping": {
    "basic_info": {
      "name": {
        "data_source": "parsed_data.basic_info.name",
        "type": "direct",
        "transform": null
      },
      "phone": {
        "data_source": "parsed_data.basic_info.phone",
        "type": "direct",
        "transform": null
      }
    },
    "work_experience": {
      "company": {
        "data_source": "parsed_data.work_experiences[].company",
        "type": "direct",
        "transform": null
      },
      "period": {
        "data_source": "parsed_data.work_experiences[]",
        "type": "combine",
        "transform": "combine(start_date, end_date, format='YYYY-MM - YYYY-MM')"
      }
    }
  },
  "complex_fields": [
    {
      "component_type": "work_experience",
      "field_id": "responsibilities",
      "field_type": "textarea",
      "label": "工作职责",
      "description": "需要从工作描述中提取"
    }
  ]
}
```

## 四、大模型的Prompt设计

### System Prompt（系统提示词）

```
你是一位资深的简历模板分析专家。你的任务是分析模板结构，生成字段映射规则，用于将解析后的简历数据填充到模板中。

核心任务：
1. **分析模板结构**：理解每个组件的类型、字段列表、字段含义
2. **生成映射规则**：为每个字段生成数据源路径和转换规则
3. **识别复杂字段**：标记哪些字段需要特殊处理（如组合、提取、转换）

输出格式要求：
- 必须使用JSON格式输出
- 包含每个组件的字段映射规则
- 标记需要AI处理的复杂字段
```

### User Prompt（用户提示词）

包含：
1. **模板结构信息**：以JSON格式发送所有组件和字段信息
2. **分析任务说明**：针对不同组件类型的映射规则说明
3. **输出格式示例**：提供完整的JSON输出格式示例
4. **重要提示**：特殊字段的处理规则

**关键提示**：
- 基本信息组件：字段如 name、phone、email、current_location 等
- 工作经历组件：period 需要组合 start_date 和 end_date
- 教育背景组件：education_level 和 degree 是不同的字段
- 技能组件：technical、soft、languages
- 项目组件：project_name、project_description、project_role、project_achievements

## 五、错误处理和容错机制

### 1. 超时处理

**超时时间**：30秒

**处理方式**：
```python
try:
    field_mapping = await asyncio.wait_for(
        llm_service.analyze_template_structure(template_schema),
        timeout=30.0
    )
except asyncio.TimeoutError:
    # 超时后使用默认映射规则
    template_schema["field_mapping"] = {
        "field_mapping": {},
        "complex_fields": []
    }
```

**影响**：
- 模板仍会正常保存
- 但不会包含预分析的映射规则
- 后续填充时会使用直接映射作为后备方案

### 2. 异常处理

**处理方式**：
```python
except Exception as e:
    # 如果分析失败，继续创建模板，但不包含映射规则
    logger.warning(f"[模板创建] 模板结构分析失败: {e}，将使用默认映射规则")
    template_schema["field_mapping"] = {
        "field_mapping": {},
        "complex_fields": []
    }
```

**影响**：
- 模板创建不会因为AI分析失败而失败
- 系统会记录警告日志
- 后续填充时使用直接映射

### 3. 映射规则验证

**验证逻辑**：
```python
has_valid_mapping = False
if field_mapping and isinstance(field_mapping, dict):
    inner_mapping = field_mapping.get("field_mapping", {})
    if inner_mapping and isinstance(inner_mapping, dict) and len(inner_mapping) > 0:
        has_valid_mapping = True
```

**验证内容**：
- 检查返回结果是否为字典
- 检查是否包含 `field_mapping` 键
- 检查 `field_mapping` 是否为空

## 六、存储位置

### 数据库字段

**表名**：`resume_templates`

**字段名**：`template_schema` (JSON类型)

**存储结构**：
```json
{
  "components": [...],
  "style": {...},
  "field_mapping": {
    "field_mapping": {...},
    "complex_fields": [...]
  }
}
```

**说明**：
- `field_mapping` 作为 `template_schema` 的一个子字段存储
- 与模板结构数据一起保存，便于后续使用

## 七、后续使用

### 模板填充时使用映射规则

**使用场景**：当用户使用模板生成简历时

**使用流程**：
```
用户选择模板生成简历
  ↓
fill_template_with_resume_data() 函数
  ↓
检查 template_schema 中是否有 field_mapping
  ↓
如果有，使用 _fill_template_with_mapping_rules() 快速填充
  ↓
如果有复杂字段，调用AI补全
```

**优势**：
1. **性能优化**：直接使用映射规则，减少AI调用
2. **准确性提升**：预分析的映射规则更准确
3. **成本降低**：减少每次填充时的AI调用次数

## 八、技术细节

### 1. LLM Provider选择

**选择逻辑**：
```python
# 设置用户上下文，以便根据用户配置或系统配置选择provider
llm_service.set_user_context(current_user, db)
```

**支持的Provider**：
- DeepSeek
- 豆包（Doubao）
- 千问（Qwen）

**选择优先级**：
1. 用户个人配置的LLM（如果用户配置了）
2. 系统配置的LLM（按优先级：DeepSeek → Doubao → Qwen）

### 2. 调用参数

**参数设置**：
```python
response = await self.chat_completion(
    messages, 
    temperature=0.1,  # 低温度，确保输出稳定
    max_tokens=2000   # 最大token数
)
```

**参数说明**：
- `temperature=0.1`：低温度确保输出结果稳定、可预测
- `max_tokens=2000`：足够生成完整的映射规则

### 3. JSON解析

**解析方法**：
```python
mapping_rules = self._parse_json_response(response)
```

**处理逻辑**：
- 从LLM返回的文本中提取JSON
- 验证JSON格式
- 如果解析失败，返回默认空映射规则

## 九、工作效果

### 成功情况

**日志输出**：
```
[模板创建] 开始分析模板结构，组件数: 5
[模板分析] 开始分析模板结构，组件数: 5
[模板分析] 分析完成，生成映射规则
[模板创建] 字段映射规则生成成功，包含组件类型: ['basic_info', 'work_experience', 'education']
```

**结果**：
- 模板成功保存
- `template_schema` 中包含完整的 `field_mapping`
- 后续填充时可以使用预分析的映射规则

### 失败情况

**超时**：
```
[模板创建] 模板结构分析超时（30秒），将使用默认映射规则
```

**异常**：
```
[模板创建] 模板结构分析失败: <错误信息>，将使用默认映射规则
```

**结果**：
- 模板仍会成功保存
- `template_schema` 中包含空的 `field_mapping`
- 后续填充时使用直接映射作为后备方案

## 十、总结

### 大模型在模板保存时的主要工作

1. **分析模板结构**：理解模板的所有组件和字段
2. **生成映射规则**：为每个字段生成数据源路径和转换规则
3. **识别复杂字段**：标记需要AI处理的字段
4. **优化后续填充**：预分析的结果用于后续模板填充，提高性能和准确性

### 关键特性

- **异步处理**：使用 `asyncio.wait_for` 设置超时
- **容错机制**：即使AI分析失败，模板仍能正常保存
- **性能优化**：预分析减少后续填充时的AI调用
- **准确性提升**：通过预分析确保字段映射的准确性

### 存储位置

- 映射规则存储在 `template_schema.field_mapping` 中
- 与模板结构数据一起保存在 `resume_templates` 表的 `template_schema` 字段

### 后续使用

- 模板填充时优先使用预分析的映射规则
- 如果没有映射规则或映射规则无效，使用直接映射作为后备方案
- 复杂字段仍需要调用AI进行补全

