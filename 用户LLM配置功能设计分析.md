# 用户 LLM 配置功能设计分析

## 当前状态

### ✅ 已实现的功能

1. **后端数据模型**：
   - `UserLLMConfig` 模型已存在（`backend/app/models/user_llm_config.py`）
   - 数据库迁移已创建（`user_llm_configs` 表）
   - 支持存储：`provider`、`api_key`、`base_url`、`model_name`

2. **后端 API**：
   - `GET /users/me/llm-config` - 获取用户配置
   - `PUT /users/me/llm-config` - 更新用户配置
   - API 密钥脱敏处理已实现

3. **后端服务逻辑**：
   - `LLMService._get_user_llm_config()` 方法已实现
   - 用户配置优先级已在 `_get_api_key()` 中实现
   - 支持管理员账户和免费期用户的特殊处理

4. **前端界面**：
   - `frontend/src/pages/Settings.tsx` 中已有 LLM 配置表单
   - 支持选择 provider（DeepSeek/豆包）
   - 支持配置 API key、base_url、model_name

### ⚠️ 存在的问题

1. **API Key 加密存储**：
   - 用户配置的 API key **没有加密存储**（系统配置有加密）
   - 存在安全风险

2. **优先级逻辑复杂**：
   - 当前逻辑：管理员/免费期用户 → 使用平台 Key
   - 普通用户 → 使用用户配置（如果存在）
   - 需要更清晰的优先级说明

3. **与管理员配置的关系**：
   - 用户配置的 provider 如果被管理员关闭，会发生什么？
   - 需要明确边界和冲突处理

## 设计建议

### 1. 优先级设计（清晰分层）

```
优先级从高到低：
┌─────────────────────────────────────────┐
│ 1. 用户个人配置（如果存在且有效）          │
│    - 用户配置的 provider + API key       │
│    - 但必须检查：该 provider 是否被管理员关闭 │
└─────────────────────────────────────────┘
           ↓ (如果用户配置不存在或无效)
┌─────────────────────────────────────────┐
│ 2. 系统默认配置（管理员配置）              │
│    - 系统默认 provider（deepseek）       │
│    - 系统配置的 API key                  │
│    - 受管理员开关控制                    │
└─────────────────────────────────────────┘
           ↓ (如果系统配置不可用)
┌─────────────────────────────────────────┐
│ 3. Fallback 机制                         │
│    - 尝试其他可用的 provider             │
│    - 按顺序：deepseek → doubao           │
└─────────────────────────────────────────┘
```

### 2. 冲突处理机制

#### 2.1 Provider 开关冲突

**场景**：用户配置了 DeepSeek，但管理员关闭了 DeepSeek 的系统开关

**处理方案**：
- **方案 A（推荐）**：用户配置不受管理员开关影响
  - 用户配置的 provider 即使被管理员关闭，用户仍可使用
  - 理由：用户使用的是自己的 API key，不消耗平台资源
  - 实现：在 `_is_provider_enabled` 中，如果是用户配置的 provider，跳过系统开关检查

- **方案 B**：用户配置受管理员开关影响
  - 如果用户配置的 provider 被管理员关闭，fallback 到系统配置
  - 理由：统一管理，避免混乱
  - 实现：在 `_get_api_key` 中，检查用户配置的 provider 是否启用

**推荐方案 A**，因为：
1. 用户使用自己的 API key，不消耗平台资源
2. 更灵活，用户可以选择任何 provider
3. 符合 SaaS 平台的常见做法

#### 2.2 API Key 冲突

**场景**：用户配置了 API key，但系统配置也有 API key

**处理方案**：
- 用户配置优先，直接使用用户配置的 API key
- 系统配置作为 fallback（如果用户配置无效）

### 3. 安全设计

#### 3.1 API Key 加密存储

**问题**：当前用户配置的 API key 是明文存储

**解决方案**：
- 使用与系统配置相同的加密机制（Fernet）
- 在 `update_my_llm_config` API 中加密存储
- 在 `_get_user_llm_config` 中解密读取

**实现位置**：
- `backend/app/api/v1/endpoints/users.py` - `update_my_llm_config`
- `backend/app/services/llm_service.py` - `_get_user_llm_config`

#### 3.2 权限控制

**当前状态**：任何登录用户都可以配置

**建议**：
- 保持当前设计（所有用户都可以配置）
- 但可以添加"使用平台 Key"的开关选项
- 让用户可以选择：使用自己的 Key 还是平台 Key

### 4. 用户体验设计

#### 4.1 配置界面优化

**当前界面**：`frontend/src/pages/Settings.tsx`

**建议改进**：
1. **添加"使用平台 Key"开关**：
   - 默认开启（使用平台 Key）
   - 关闭后显示配置表单（使用自己的 Key）

2. **Provider 选择优化**：
   - 显示每个 provider 的状态（是否被管理员关闭）
   - 如果用户选择的 provider 被关闭，显示警告

3. **配置状态提示**：
   - 显示当前使用的配置来源（用户配置/平台配置）
   - 显示当前使用的 provider

#### 4.2 配置验证

**建议**：
- 添加"测试连接"功能（类似管理员配置）
- 保存前验证 API key 是否有效
- 提供配置建议（如果 base_url 或 model_name 为空）

### 5. 管理员配置与用户配置的关系

#### 5.1 清晰的边界

```
管理员配置（系统配置）：
├── 作用范围：所有用户（如果没有用户配置）
├── 控制内容：
│   ├── Provider 开关（llm.<provider>.enabled）
│   ├── 系统 API key（供所有用户使用）
│   ├── 默认 base_url 和 model_name
│   └── 影响：免费用户、试用期用户、未配置用户
└── 管理位置：管理后台 → 系统配置

用户配置（个人配置）：
├── 作用范围：单个用户
├── 控制内容：
│   ├── 个人选择的 provider
│   ├── 个人 API key（加密存储）
│   ├── 个人 base_url 和 model_name
│   └── 影响：仅该用户
└── 管理位置：个人设置 → LLM配置
```

#### 5.2 互不干扰原则

**原则**：
1. **用户配置优先**：如果用户配置了，优先使用用户配置
2. **系统配置作为默认**：如果用户没有配置，使用系统配置
3. **独立管理**：用户配置不受管理员开关影响（如果使用自己的 Key）
4. **Fallback 机制**：如果用户配置的 provider 不可用，fallback 到系统配置

### 6. 特殊用户处理

#### 6.1 管理员账户

**当前逻辑**：
```python
if user.user_type in ['super_admin', 'template_designer']:
    return None  # 使用平台Key
```

**建议**：
- 保持当前逻辑（管理员使用平台 Key）
- 但可以允许管理员也配置个人 Key（如果需要）

#### 6.2 免费期用户

**当前逻辑**：
```python
if user.platform_key_expires_at and user.platform_key_expires_at > datetime.utcnow():
    return None  # 免费期内，使用平台Key
```

**建议**：
- 保持当前逻辑（免费期使用平台 Key）
- 但允许用户提前配置个人 Key（免费期结束后自动切换）

### 7. 实现建议（优先级）

#### 高优先级（必须实现）

1. **API Key 加密存储**
   - 使用 `config_service._encrypt()` 加密
   - 使用 `config_service._decrypt()` 解密

2. **Provider 开关冲突处理**
   - 明确：用户配置的 provider 不受管理员开关影响
   - 实现：在 `_is_provider_enabled` 中添加用户配置检查

3. **配置状态显示**
   - 前端显示当前使用的配置来源
   - 显示当前使用的 provider

#### 中优先级（建议实现）

4. **"使用平台 Key"开关**
   - 让用户可以选择使用平台 Key 还是个人 Key
   - 简化配置流程

5. **配置验证**
   - 添加"测试连接"功能
   - 保存前验证 API key

#### 低优先级（可选实现）

6. **配置建议**
   - 如果 base_url 或 model_name 为空，提供默认值建议
   - 根据 provider 自动填充默认值

7. **使用统计**
   - 记录用户使用个人 Key 的次数
   - 显示使用情况（可选）

## 总结

### 当前状态
- ✅ 用户配置功能**已经实现**（后端 + 前端）
- ⚠️ 但存在安全问题（API key 未加密）
- ⚠️ 优先级逻辑需要优化

### 设计原则
1. **用户配置优先**：如果用户配置了，优先使用
2. **独立管理**：用户配置不受管理员开关影响（如果使用自己的 Key）
3. **系统配置作为默认**：没有用户配置时，使用系统配置
4. **Fallback 机制**：如果用户配置不可用，fallback 到系统配置

### 不会发生冲突
- 用户配置和系统配置是**互补关系**，不是冲突关系
- 用户配置优先，系统配置作为 fallback
- 管理员开关只影响系统配置，不影响用户配置（如果用户使用自己的 Key）

### 需要改进的地方
1. **安全**：API key 加密存储
2. **逻辑**：明确用户配置的 provider 不受管理员开关影响
3. **体验**：添加"使用平台 Key"开关，简化配置流程

